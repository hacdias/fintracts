{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://fintracts-builder/./node_modules/@riotjs/hot-reload/index.js","webpack://fintracts-builder/./src/components/agreements/bond-purchase/bond-purchase.riot","webpack://fintracts-builder/./src/components/agreements/bond-purchase/coupons/coupons.riot","webpack://fintracts-builder/./src/components/agreements/currency-swap/currency-swap.riot","webpack://fintracts-builder/./src/components/agreements/interest-rate-swap/interest-rate-swap.riot","webpack://fintracts-builder/./src/components/frame-box/frame-box.riot","webpack://fintracts-builder/./src/components/global/builder/builder.riot","webpack://fintracts-builder/./src/components/primitives/date/date.riot","webpack://fintracts-builder/./src/components/primitives/dates/dates.riot","webpack://fintracts-builder/./src/components/primitives/exchange-rate/exchange-rate.riot","webpack://fintracts-builder/./src/components/primitives/interest-payment/interest-payment.riot","webpack://fintracts-builder/./src/components/primitives/interest-payments/interest-payments.riot","webpack://fintracts-builder/./src/components/primitives/money/money.riot","webpack://fintracts-builder/./src/components/primitives/party-select/party-select.riot","webpack://fintracts-builder/./src/components/screens/agreements/agreements.riot","webpack://fintracts-builder/./src/components/screens/contract/contract.riot","webpack://fintracts-builder/./src/components/screens/parties/parties.riot","webpack://fintracts-builder/./src/components/screens/screen/screen.riot","webpack://fintracts-builder/./src/components/screens/signatures/signatures.riot","webpack://fintracts-builder/./node_modules/bianco.query/index.next.js","webpack://fintracts-builder/./node_modules/bianco.dom-to-array/index.next.js","webpack://fintracts-builder/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js","webpack://fintracts-builder/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js","webpack://fintracts-builder/./node_modules/tachyons/css/tachyons.css?f775","webpack://fintracts-builder/./src/style.css?e320","webpack://fintracts-builder/./node_modules/riot/riot.esm.js","webpack://fintracts-builder//home/runner/work/fintracts/fintracts/builder/src/components/global|sync|/[a-zA-Z0-9-]+\\.riot/","webpack://fintracts-builder/./src/register-global-components.js","webpack://fintracts-builder/./src/index.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n}(this, (function (exports, riot, $) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $__default['default'](`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // early return in case there is no riot instance found\n      if (!oldTag) return\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports.default = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","<bondPurchase>\n  <frame-box remove=\"Remove Agreement\" onRemove={props.onRemove} >\n    <p class=\"b mt0 mb3\">Bond Purchase Agreement</p>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Issuer</span>\n      <party-select\n        parties={props.parties}\n        onValue={onChange('issuer')}\n        selected={agreement.issuer} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Underwriter</span>\n      <party-select\n        parties={props.parties}\n        onValue={onChange('underwriter')}\n        selected={agreement.underwriter} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Face Value</span>\n      <money value={agreement.faceValue} onValue={onChange('faceValue')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Issue Price</span>\n      <money value={agreement.issuePrice} onValue={onChange('issuePrice')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Maturity Date</span>\n      <date value={agreement.maturityDate} onValue={onChange('maturityDate')} />\n    </label>\n\n    <button\n      if={!agreement.coupons}\n      title=\"Add Coupons\"\n      alt=\"Add Coupons\"\n      class=\"db bg-green br1 pv2 ph3 mt2\"\n      onclick={addCoupons}>Add Coupons</button>\n\n    <coupons\n      if={agreement.coupons}\n      coupons={agreement.coupons}\n      onCoupons={onChange('coupons')} />\n  </frame-box>\n\n  <script>\n    import FrameBox from '../../frame-box/frame-box.riot'\n    import PartySelect from '../../primitives/party-select/party-select.riot'\n    import Date from '../../primitives/date/date.riot'\n    import Money from '../../primitives/money/money.riot'\n    import Coupons from './coupons/coupons.riot'\n\n    const emptyState = () => ({\n      issuer: '',\n      underwriter: '',\n      faceValue: null,\n      issuePrice: null,\n      maturityDate: '',\n      coupons: null\n    })\n\n    export default {\n      components: {\n        PartySelect,\n        Date,\n        Money,\n        Coupons,\n        FrameBox\n      },\n      get agreement () {\n        const agreement = this.props.agreement || {}\n        const bondPurchase = agreement.bondPurchase || {}\n\n        return {\n          ...emptyState(),\n          ...bondPurchase\n        }\n      },\n      onChange (field) {\n        return (value) => {\n          const agreement = this.agreement\n          agreement[field] = value\n          this.props.onChange({ bondPurchase: agreement })\n        }\n      },\n      addCoupons () {\n        this.onChange('coupons')({})\n      }\n    }\n  </script>\n</bondPurchase>\n","<coupons>\n  <frame-box remove=\"Remove Coupons\" onRemove={removeCoupons} >\n    <p class=\"b mt0 mb3\">Coupons</p>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Rate</span>\n      <input type=\"number\" step=\"any\" placeholder=\"Rate\" class=\"w3\" value={coupons.rate} onchange={onRate} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Dates</span>\n\n      <dates\n        value={coupons.dates}\n        onValue={onDates} />\n    </label>\n  </frame-box>\n\n  <script>\n    import FrameBox from '../../../frame-box/frame-box.riot'\n    import Dates from '../../../primitives/dates/dates.riot'\n\n    const emptyState = () => ({\n      rate: null,\n      dates: []\n    })\n\n    export default {\n      components: {\n        FrameBox,\n        Dates\n      },\n      get coupons () {\n        const coupons = this.props.coupons || {}\n\n        return {\n          ...emptyState(),\n          ...coupons\n        }\n      },\n      onRate (event) {\n        const coupons = this.coupons\n        coupons.rate = Number.parseFloat(event.target.value)\n        this.props.onCoupons(coupons)\n      },\n      onDates (value) {\n        const coupons = this.coupons\n        coupons.dates = value\n        this.props.onCoupons(coupons)\n      },\n      removeCoupons () {\n        this.props.onCoupons(null)\n      }\n    }\n  </script>\n</coupons>\n","<currencySwap>\n  <frame-box remove=\"Remove Agreement\" onRemove={props.onRemove} >\n    <p class=\"b mt0 mb3\">Currency Swap</p>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Payer A</span>\n      <party-select\n        parties={props.parties}\n        onValue={onChange('payerA')}\n        selected={agreement.payerA} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Principal A</span>\n      <money value={agreement.principalA} onValue={onChange('principalA')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Payer B</span>\n      <party-select\n        parties={props.parties}\n        onValue={onChange('payerB')}\n        selected={agreement.payerB} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Principal B</span>\n      <money value={agreement.principalB} onValue={onChange('principalB')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Exchange Rate</span>\n      <exchange-rate value={agreement.impliedExchangeRate} disabled={true} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Effective Date</span>\n      <date value={agreement.effectiveDate} onValue={onChange('effectiveDate')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Maturity Date</span>\n      <date value={agreement.maturityDate} onValue={onChange('maturityDate')} />\n    </label>\n\n    <label class=\"mt2\" if={agreement.endExchangeRate}>\n      <span class=\"b mr1\">End Exchange Rate</span>\n      <span>\n        <exchange-rate value={agreement.endExchangeRate} onValue={onChange('endExchangeRate')} />\n        <button\n          id=\"remove-end-exchange-rate\"\n          onclick={removeEndExchageRate}\n          title=\"Remove End Exchange Rate\"\n          alt=\"Remove End Exchange Rate\"\n          class=\"bg-red round ml2\">X</button>\n      </span>\n    </label>\n\n    <button\n      if={!agreement.endExchangeRate}\n      id=\"add-end-exchange-rate\"\n      title=\"Add End Exchange Rate\"\n      alt=\"Add End Exchange Rate\"\n      class=\"db bg-green br1 pv2 ph3 mt2\"\n      onclick={addEndExchangeRate}>Add End Exchange Rate</button>\n\n    <label class=\"mt2\" if={agreement.interest}>\n      <span class=\"b mr1\">Interest Payments</span>\n      <span>\n        <interest-payments\n          parties={props.parties}\n          value={agreement.interest}\n          onValue={onChange('interest')} />\n\n        <button\n          id=\"remove-end-exchange-rate\"\n          onclick={removeInterestPayments}\n          title=\"Remove Interest Payments\"\n          alt=\"Remove Interest Payments\"\n          class=\"db bg-green br1 pv2 ph3 mt2\">Remove Interest Payments</button>\n      </span>\n    </label>\n\n    <button\n      if={!agreement.interest}\n      id=\"add-interest-payments\"\n      title=\"Add Interest Payments\"\n      alt=\"Add Interest Payments\"\n      class=\"db bg-green br1 pv2 ph3 mt2\"\n      onclick={addInterestPayments}>Add Interest Payments</button>\n  </frame-box>\n\n  <script>\n    import PartySelect from '../../primitives/party-select/party-select.riot'\n    import Date from '../../primitives/date/date.riot'\n    import Money from '../../primitives/money/money.riot'\n    import ExchangeRate from '../../primitives/exchange-rate/exchange-rate.riot'\n    import InterestPayments from '../../primitives/interest-payments/interest-payments.riot'\n    import FrameBox from '../../frame-box/frame-box.riot'\n\n    const emptyState = () => ({\n      payerA: null,\n      principalA: null,\n      payerB: null,\n      principalB: null,\n      impliedExchangeRate: {\n        baseCurrency: '',\n        counterCurrency: '',\n        rate: 1.0\n      },\n      endExchangeRate: null, // TODO: can be optional\n      interest: null, // TODO: can be optional\n      effectiveDate: null,\n      maturityDate: null\n    })\n\n    export default {\n      components: {\n        PartySelect,\n        Date,\n        Money,\n        ExchangeRate,\n        FrameBox,\n        InterestPayments\n      },\n      get agreement () {\n        const agreement = this.props.agreement || {}\n        const currencySwap = agreement.currencySwap || {}\n\n        return {\n          ...emptyState(),\n          ...currencySwap\n        }\n      },\n      addEndExchangeRate () {\n        this.onChange('endExchangeRate')({})\n      },\n      removeEndExchageRate () {\n        this.onChange('endExchangeRate')(null)\n      },\n      addInterestPayments () {\n        this.onChange('interest')([])\n      },\n      removeInterestPayments () {\n        this.onChange('interest')(null)\n      },\n      onChange (field) {\n        return (value) => {\n          const agreement = this.agreement\n          agreement[field] = value\n\n          if (agreement.principalA && agreement.principalB) {\n            const principalA = agreement.principalA\n            const principalB = agreement.principalB\n\n            agreement.impliedExchangeRate.baseCurrency = principalA.currency\n            agreement.impliedExchangeRate.counterCurrency = principalB.currency\n\n            if (principalA.amount !== 0 && principalB.amount !== 0) {\n              agreement.impliedExchangeRate.rate = principalB.amount / principalA.amount\n            }\n          }\n\n          this.props.onChange({ currencySwap: agreement })\n        }\n      }\n    }\n  </script>\n</currencySwap>\n","<interestRateSwap>\n  <frame-box remove=\"Remove Agreement\" onRemove={props.onRemove} >\n    <p class=\"b mt0 mb3\">Interest Rate Swap</p>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Notational Amount</span>\n      <money value={agreement.notationalAmount} onValue={onChange('notationalAmount')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Effective Date</span>\n      <date value={agreement.effectiveDate} onValue={onChange('effectiveDate')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Maturity Date</span>\n      <date value={agreement.maturityDate} onValue={onChange('maturityDate')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Interest Payments</span>\n      <interest-payments\n        parties={props.parties}\n        value={agreement.interest}\n        onValue={onChange('interest')} />\n    </label>\n  </frame-box>\n\n  <script>\n    import Date from '../../primitives/date/date.riot'\n    import Money from '../../primitives/money/money.riot'\n    import InterestPayments from '../../primitives/interest-payments/interest-payments.riot'\n    import FrameBox from '../../frame-box/frame-box.riot'\n\n    const emptyState = () => ({\n      notationalAmount: null,\n      effectiveDate: null,\n      maturityDate: null,\n      interest: null\n    })\n\n    export default {\n      components: {\n        Date,\n        Money,\n        FrameBox,\n        InterestPayments\n      },\n      get agreement () {\n        const agreement = this.props.agreement || {}\n        const interestRateSwap = agreement.interestRateSwap || {}\n\n        return {\n          ...emptyState(),\n          ...interestRateSwap\n        }\n      },\n      onChange (field) {\n        return (value) => {\n          const agreement = this.agreement\n          agreement[field] = value\n          this.props.onChange({ interestRateSwap: agreement })\n        }\n      }\n    }\n  </script>\n</interestRateSwap>\n","<frame-box>\n  <div class=\"mv3 pa3 relative ba b--black-20 frame\">\n    <button\n      if={props.onRemove}\n      onclick={props.onRemove}\n      title={props.remove}\n      alt={props.remove}\n      class=\"bg-red round floating\">X</button>\n\n    <slot/>\n  </div>\n</frame-box>\n","<builder>\n  <div>\n    <parties\n      if={state.state === 'Parties'}\n      value={state.parties}\n      onValue={onValue('parties')}\n      onDone={onPartiesDone} />\n\n    <agreements\n      if={state.state === 'Agreements'}\n      parties={state.parties}\n      value={state.agreements}\n      onValue={onValue('agreements')}\n      onDone={onAgreementsDone} />\n\n    <signatures\n      if={state.state === 'Signatures'}\n      parties={state.parties}\n      value={state.signatures}\n      onValue={onValue('signatures')}\n      onDone={onSignaturesDone} />\n  \n    <contract\n      if={state.state === 'Contract'}\n      contract={contract} />\n\n    <hr />\n\n    <div>\n      <button class=\"bg-red br1 pv2 ph3\" onclick={reset}>Reset</button>\n    </div>\n  </div>\n\n  <script>\n    import Parties from '../../screens/parties/parties.riot'\n    import Agreements from '../../screens/agreements/agreements.riot'\n    import Contract from '../../screens/contract/contract.riot'\n    import Signatures from '../../screens/signatures/signatures.riot'\n\n    const State = {\n      Parties: 'Parties',\n      Agreements: 'Agreements',\n      Signatures: 'Signatures',\n      Contract: 'Contract'\n    }\n\n    const emptyState = () => ({\n      state: State.Parties,\n      parties: null,\n      agreements: null,\n      signatures: null\n    })\n\n    export default {\n      components: {\n        Parties,\n        Agreements,\n        Signatures,\n        Contract\n      },\n      state: emptyState(),\n      onValue (field) {\n        return (value) => {\n          this.update({\n            [field]: value\n          })\n        }\n      },\n      onPartiesDone () {\n        this.update({ state: State.Agreements })\n      },\n      onAgreementsDone () {\n        this.update({ state: State.Signatures })\n      },\n      onSignaturesDone () {\n        this.update({ state: State.Contract })\n      },\n      get contract () {\n        return {\n          parties: this.state.parties,\n          agreements: this.state.agreements,\n          signatures: this.state.signatures\n        }\n      },\n      reset ()  {\n        this.update(emptyState())\n      }\n    }\n  </script>\n</builder>\n","<date>\n  <input type=\"date\" class={props.class} onchange={onChange} value={value}/></p>\n\n  <script>\n    export default {\n      get value () {\n        if (this.props.value) return this.props.value.split('T')[0]\n        return ''\n      },\n      onChange (event) {\n        const date = event.target.value\n        this.props.onValue(`${date}T00:00:00Z`)\n      }\n    }\n  </script>\n</date>\n","<dates>\n  <div>\n    <div each={ (date, index) in value } class=\"mb2 flex items-center\">\n      <date value={date} onValue={onDate(index)} />\n      <button\n        onclick={removeDate(index)}\n        title=\"Remove Date\"\n        alt=\"Remove Date\"\n        class=\"bg-red round ml2\">X</button>\n    </div>\n\n    <button\n      title=\"Add Date\"\n      alt=\"Add Date\"\n      class=\"db bg-green br1 pv2 ph3\"\n      onclick={addDate}>Add Date</button> \n  </div>\n\n  <script>\n    import Date from '../date/date.riot'\n\n    const emptyState = () => []\n\n    export default {\n      components: {\n        Date\n      },\n      get value () {\n        return this.props.value || []\n      },\n      onDate (index) {\n        return (value) => {\n          const dates = this.value\n          dates[index] = value\n          this.props.onValue(dates)\n        }\n      },\n      addDate () {\n        const dates = [...this.value, '']\n        this.props.onValue(dates)\n      },\n      removeDate (index) {\n        return () => {\n          const dates = this.value\n          dates.splice(index, 1)\n          this.props.onValue(dates)\n        }\n      }\n    }\n  </script>\n</dates>\n","<exchange-rate>\n  <input onchange={onChange('baseCurrency')} disabled={props.disabled} type=\"text\" maxlength=\"3\" minlength=\"3\" value={value.baseCurrency} placeholder=\"CUR\" class=\"mr1 w3\" /> /\n  <input onchange={onChange('counterCurrency')} disabled={props.disabled} type=\"text\" maxlength=\"3\" minlength=\"3\" value={value.counterCurrency} placeholder=\"CUR\" class=\"mr1 w3\"  />\n  <input onchange={onChange('rate')} disabled={props.disabled} type=\"number\" step=\"any\" value={value.rate} placeholder=\"Rate\" class=\"w3\"  />\n\n  <script>\n    const emptyState = () => ({\n      baseCurrency: '',\n      counterCurrency: '',\n      rate: null\n    })\n\n    export default {\n      get value () {\n        const value = this.props.value || {}\n        return {\n          ...emptyState(),\n          ...value\n        }\n      },\n      onChange (field) {\n        return (event) => {\n          const value = this.value\n          if (event.target.type === 'number') {\n            value[field] = Number.parseFloat(event.target.value)\n          } else {\n            value[field] = event.target.value\n          }\n          this.props.onValue(value)\n        }\n      }\n    }\n  </script>\n</exchange-rate>\n","<interest-payment>\n  <frame-box remove=\"Remove Payment\" onRemove={removeCoupons} remove={props.remove} onRemove={props.onRemove}>\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Payer</span>\n      <party-select\n        parties={props.parties}\n        onValue={onChange('payer', true)}\n        selected={value.payer} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Type</span>\n      <div onchange={onRateType}>\n        <div><input type=\"radio\" class=\"mr1\" value=\"floating\" checked={isFloating} /> Floating Type</div>\n        <div><input type=\"radio\" class=\"mr1\" value=\"fixed\" checked={!isFloating} /> Fixed Type</div>\n      </div>\n    </label>\n\n    <label class=\"mt2\" if={!isFloating}>\n      <span class=\"b mr1\">Fixed Rate</span>\n      <input type=\"number\" step=\"any\" placeholder=\"Rate\" class=\"w3\" value={value.fixedRate} onchange={onChange('fixedRate')} />\n    </label>\n\n    <label class=\"mt2\" if={isFloating}>\n      <span class=\"b mr1\">Initial Rate</span>\n      <input type=\"number\" step=\"any\" placeholder=\"Rate\" class=\"w3\" value={value.initialRate} onchange={onChange('initialRate')} />\n    </label>\n\n    <label class=\"mt2\" if={isFloating}>\n      <span class=\"b mr1\">Rate Option</span>\n      <input type=\"text\" placeholder=\"Rate Option\" class=\"w5\" value={value.rateOption} onchange={onChange('rateOption')} />\n    </label>\n\n    <label class=\"mt2\">\n      <span class=\"b mr1\">Dates</span>\n\n      <dates\n        value={value.dates}\n        onValue={onChange('dates', true)} />\n    </label>\n  </frame-box>\n\n  <script>\n    import FrameBox from '../../frame-box/frame-box.riot'\n    import Dates from '../dates/dates.riot'\n    import PartySelect from '../party-select/party-select.riot'\n\n    const emptyState = () => ({\n      payer: '',\n      dates: [],\n    })\n\n    export default {\n      components: {\n        FrameBox,\n        PartySelect,\n        Dates\n      },\n      get value () {\n        const value = this.props.value || {}\n        return { ...emptyState(), ...value }\n      },\n      get isFloating () {\n        const agreement = this.value\n        return ('initialRate' in agreement && 'rateOption' in agreement)\n      },\n      onRateType (event) {\n        const type = event.target.value\n        const agreement = this.value\n\n        if (type === 'floating') {\n          delete agreement.fixedRate\n          agreement.initialRate = 0\n          agreement.rateOption = ''\n        } else {\n          delete agreement.initialRate\n          delete agreement.rateOption\n          agreement.fixedRate = 0\n        }\n\n        this.props.onValue(agreement)\n      },\n      onChange (field, isValue) {\n        return (eventOrValue) => {\n          const value = this.value\n          if (isValue) {\n            value[field] = eventOrValue\n          } else if (event.target.type === 'number') {\n            value[field] = Number.parseFloat(event.target.value)\n          } else {\n            value[field] = event.target.value\n          }\n          this.props.onValue(value)\n        }\n      }\n    }\n  </script>\n</interest-payment>\n","<interest-payments>\n  <div>\n    <div each={ (date, index) in value } class=\"mb2 flex items-center\">\n      <interest-payment\n        value={date}\n        parties={props.parties}\n        remove=\"Remove Interest Payment\"\n        onValue={onValue(index)}\n        onRemove={removeItem(index)}\n        class=\"flex-grow-1\" />\n    </div>\n\n    <button\n      title=\"Add Interest Payment\"\n      alt=\"Add Interest Payment\"\n      class=\"db bg-green br1 pv2 ph3\"\n      onclick={addItem}>Add Interest Payment</button>\n  </div>\n\n  <script>\n    import InterestPayment from '../interest-payment/interest-payment.riot'\n\n    const emptyState = () => []\n\n    export default {\n      components: {\n        InterestPayment\n      },\n      get value () {\n        return this.props.value || []\n      },\n      onValue (index) {\n        return (newValue) => {\n          const value = this.value\n          value[index] = newValue\n          this.props.onValue(value)\n        }\n      },\n      addItem (event) {\n        // BUG: triggered every time we click on white space within\n        // the whole interest-payments block.\n        event.preventDefault()\n        event.stopPropagation()\n\n        const value = [...this.value, '']\n        this.props.onValue(value)\n      },\n      removeItem (index) {\n        return (event) => {\n          // BUG: this gets propagated to addItem for no reason.\n          event.preventDefault()\n          event.stopPropagation()\n\n          const value = this.value\n          value.splice(index, 1)\n          this.props.onValue(value)\n        }\n      }\n    }\n  </script>\n</interest-payments>\n","<money>\n  <input type=\"text\" maxlength=\"3\" minlength=\"3\" placeholder=\"CUR\" class=\"mr1 w3\" value={value.currency} onchange={onChange} />\n  <input type=\"number\" step=\"any\" placeholder=\"Amount\" class=\"w5\" value={value.amount} onchange={onChange} />\n  \n  <script>\n    const emptyValue = () => ({\n      currency: '',\n      amount: null\n    })\n\n    export default {\n      get value () {\n        const value = this.props.value || {}\n        return {\n          ...emptyValue(),\n          ...value\n        }\n      },\n      onChange (event) {\n        const type = event.target.type\n        const value = this.value\n        if (type === 'text') {\n          value.currency = event.target.value.toUpperCase()\n        } else {\n          value.amount = Number.parseFloat(event.target.value)\n        }\n        this.props.onValue(value)\n      }\n    }\n  </script>\n</money>\n","<party-select>\n  <select onchange={onChange}>\n    <option disabled selected value>Select a Party</option>\n    <option each={ party in props.parties } value={party.identifier} selected={props.selected === party.identifier}>{party.name} ({party.identifier})</option>\n  </select>\n\n  <script>\n    export default {\n      onChange (event) {\n        const party = event.target.value\n        this.props.onValue(party)\n      }\n    }\n  </script>\n</party-select>\n","<agreements>\n  <screen title=\"Agreements\">\n    <p class=\"mt1 i\">A contract can have one or more agreements.</p>\n\n    <div each={ (agreement, index) in agreements }>\n      <bond-purchase\n        if={agreement.bondPurchase}\n        parties={props.parties}\n        agreement={agreement}\n        onRemove={onRemoveAgreement(index)}\n        onChange={onAgreement(index)} />\n\n      <interest-rate-swap\n        if={agreement.interestRateSwap}\n        parties={props.parties}\n        agreement={agreement}\n        onRemove={onRemoveAgreement(index)}\n        onChange={onAgreement(index)} />\n\n      <currency-swap\n        if={agreement.currencySwap}\n        parties={props.parties}\n        agreement={agreement}\n        onRemove={onRemoveAgreement(index)}\n        onChange={onAgreement(index)} />\n    </div>\n\n    <div class=\"mv3 pa3 relative ba b--black-20\" onchange={onAgreementType}>\n      <p class=\"b mt0 mb3\">Agreement Type</p>\n      <div each={ (key) in types } class=\"mt2\">\n        <input type=\"radio\" class=\"mr1\" value={key.id} checked={state.type === key.id} /> {key.title}\n      </div>\n\n      <button class=\"center db bg-green br1 pv2 ph3\" onclick={addAgreement}>Add Agreement</button>\n    </div>\n\n    <div class=\"flex items-center justify-end\" if={canNext}>\n      <button class=\"bg-blue br1 pv2 ph3\" onclick={submit}>Next</button>\n    </div>\n  </screen>\n\n  <script>\n    import Screen from '../screen/screen.riot'\n    import BondPurchase from '../../agreements/bond-purchase/bond-purchase.riot'\n    import InterestRateSwap from '../../agreements/interest-rate-swap/interest-rate-swap.riot'\n    import CurrencySwap from '../../agreements/currency-swap/currency-swap.riot'\n\n    const newParty = () => ({\n      name: '',\n      identifier: ''\n    })\n\n    export default {\n      types: [\n        { id: 'bondPurchase', title: 'Bond Purchase' },\n        { id: 'interestRateSwap', title: 'Interest Rate Swap' },\n        { id: 'currencySwap', title: 'Currency Swap' }\n      ],\n      state: {\n        type: '',\n      },\n      components: {\n        Screen,\n        BondPurchase,\n        InterestRateSwap,\n        CurrencySwap\n      },\n      get agreements () {\n        return this.props.value || []\n      },\n      onAgreement (index) {\n        return (agreement) => {\n          const agreements = this.agreements\n          agreements[index] = agreement\n          this.props.onValue(agreements)\n        }\n      },\n      onRemoveAgreement (index) {\n        return () => {\n          const agreements = this.agreements\n          agreements.splice(index, 1)\n          this.props.onValue(agreements)\n        }\n      },\n      onAgreementType (event) {\n        this.update({ type: event.target.value })\n      },\n      addAgreement () {\n        this.props.onValue([\n          ...this.agreements,\n          { [this.state.type]: {} }\n        ])\n      },\n      get canNext () {\n        return this.agreements.length >= 1\n      },\n      submit () {\n        this.props.onDone()\n      }\n    }\n  </script>\n</agreements>\n","<contract>\n  <screen title=\"Contract\">\n    <p class=\"mt1 b\">The contract JSON according to specification.</p>\n  \n    <textarea class=\"w-100 h5 db mv2\" value={text()} readonly></textarea>\n  </screen>\n\n  <script>\n    import Screen from '../screen/screen.riot'\n\n    export default {\n      components: {\n        Screen\n      },\n      text() {\n        return JSON.stringify(this.props.contract, null, '    ')\n      }\n    }\n  </script>\n</contract>","<parties>\n  <screen title=\"Parties\">\n    <p class=\"mt1 mb3 i\">The contract can have two or more parties.</p>\n\n    <frame-box\n      each={ (party, index) in parties }\n      remove=\"Remove Party\"\n      onRemove={parties.length > 2 ? deleteParty(index) : null} >\n      <label>\n        <span class=\"b mr1\">Full Name</span>\n        <input type=\"text\" placeholder=\"e.g. The Big Bank\" data-i={index} data-key=\"name\" onchange={updateParty} value={party.name} />\n      </label>\n\n      <label class=\"mt2\">\n        <span class=\"b mr1\">Identifier</span>\n        <input type=\"text\" placeholder=\"e.g. TBB\" data-i={index} data-key=\"identifier\" onchange={updateParty} value={party.identifier} />\n      </label>\n    </frame-box>\n\n    <div class=\"mv3 pa3 ba b--black-20\">\n      <button class=\"center db bg-green br1 pv2 ph3\" onclick={addParty}>Add Party</button>\n    </div>\n\n    <div class=\"flex items-center justify-end\" if={canNext}>\n      <button class=\"bg-blue br1 pv2 ph3\" onclick={submit}>Next</button>\n    </div>\n  </screen>\n\n  <script>\n    import FrameBox from '../../frame-box/frame-box.riot'\n    import Screen from '../screen/screen.riot'\n    import Date from '../../primitives/date/date.riot'\n\n    const newParty = () => ({\n      name: '',\n      identifier: ''\n    })\n\n    export default {\n      components: {\n        Screen,\n        Date,\n        FrameBox\n      },\n      get parties () {\n        const parties = this.props.value\n        if (Array.isArray(parties)) {\n          if (parties.length >= 2) return parties\n          else if (parties.length >= 1) return [...parties, newParty()]\n        }\n\n        return [\n          newParty(),\n          newParty()\n        ]\n      },\n      addParty () {\n        this.props.onValue([...this.parties, newParty()])\n      },\n      updateParty (event) {\n        const i = event.target.dataset.i\n        const key = event.target.dataset.key\n        const parties = this.parties\n        parties[i][key] = event.target.value\n        this.props.onValue(parties)\n      },\n      deleteParty (index) {\n        return () => {\n          const parties = this.parties\n          parties.splice(index, 1)\n          this.props.onValue(parties)\n        } \n      },\n      get canNext () {\n        return this.parties.reduce((valid, { name, identifier }) => name && identifier && valid, true)\n      },\n      submit () {\n        this.props.onDone()\n      }\n    }\n  </script>\n</parties>\n","<screen>\n  <div>\n    <h2 class=\"ma0 f4 black\">{props.title}</h2>\n    \n    <slot/>\n  </div>\n</screen>\n","<signatures>\n  <screen title=\"Signatures\">\n    <p class=\"mt1 mb3 i\">Different parties can sign on different dates.</p>\n  \n    <frame-box each={ (sig, index) in value }>\n      <label>\n        <span class=\"b mr1\">Party</span>\n        <input type=\"text\" disabled value={sig.parties[0]} />\n      </label>\n\n      <label class=\"mt2\">\n        <span class=\"b mr1\">Identifier</span>\n        <date value={sig.date} onValue={updateDate(index)} />\n      </label>\n    </frame-box>\n\n    <div class=\"flex items-center justify-end\" if={canNext}>\n      <button class=\"bg-blue br1 pv2 ph3\" onclick={submit}>Next</button>\n    </div>\n  </screen>\n\n  <script>\n    import FrameBox from '../../frame-box/frame-box.riot'\n    import Screen from '../screen/screen.riot'\n    import Date from '../../primitives/date/date.riot'\n\n    const newParty = () => ({\n      name: '',\n      identifier: ''\n    })\n\n    export default {\n      components: {\n        Screen,\n        Date,\n        FrameBox\n      },\n      get value () {\n        const parties = this.props.parties || []\n        const value = this.props.value\n          || parties.map(({ name, identifier }) => ({\n            parties: [identifier],\n            date: ''\n          }))\n\n        return value\n      },\n      updateDate (index) {\n        return (date) => {\n          const value = this.value\n          value[index].date = date\n          this.props.onValue(value)\n        } \n      },\n      get canNext () {\n        return this.value\n          .map(({ date }) => date)\n          .filter(date => date === '')\n          .length === 0\n      },\n      submit () {\n        this.props.onDone()\n      }\n    }\n  </script>\n</signatures>","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ?\n    (ctx || document).querySelectorAll(selector) :\n    selector\n  )\n}\n","/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}","\"use strict\";\n\n/* eslint-env browser */\n\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\nvar normalizeUrl = require(\"./normalize-url\");\n\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === \"undefined\";\nvar forEach = Array.prototype.forEach;\n\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    var self = this; // eslint-disable-next-line prefer-rest-params\n\n    var args = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nfunction noop() {}\n\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n\n  if (!src) {\n    if (document.currentScript) {\n      src = document.currentScript.src;\n    } else {\n      var scripts = document.getElementsByTagName(\"script\");\n      var lastScriptTag = scripts[scripts.length - 1];\n\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n\n    srcByModuleId[moduleId] = src;\n  }\n\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n\n    if (!filename) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    if (!fileMap) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    return fileMap.split(\",\").map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), \"g\");\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    } // eslint-disable-next-line\n\n\n    url = el.href.split(\"?\")[0];\n  }\n\n  if (!isUrlRequest(url)) {\n    return;\n  }\n\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n\n  if (!url || !(url.indexOf(\".css\") > -1)) {\n    return;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener(\"load\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener(\"error\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n\nfunction getReloadUrl(href, src) {\n  var ret; // eslint-disable-next-line no-param-reassign\n\n  href = normalizeUrl(href, {\n    stripWWW: false\n  }); // eslint-disable-next-line array-callback-return\n\n  src.some(function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n\n  var elements = document.querySelectorAll(\"link\");\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n\n    var url = getReloadUrl(el.href, src);\n\n    if (!isUrlRequest(url)) {\n      return;\n    }\n\n    if (el.visited === true) {\n      return;\n    }\n\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\n\nfunction reloadAll() {\n  var elements = document.querySelectorAll(\"link\");\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n\n    updateCss(el);\n  });\n}\n\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n  // It is not http or https\n  if (!/^https?:/i.test(url)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log(\"no window.document found, will not HMR CSS\");\n    return noop;\n  }\n\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n\n    if (options.locals) {\n      console.log(\"[HMR] Detected local css modules. Reload all css\");\n      reloadAll();\n      return;\n    }\n\n    if (reloaded) {\n      console.log(\"[HMR] css reload %s\", src.join(\" \"));\n    } else {\n      console.log(\"[HMR] Reload all css\");\n      reloadAll();\n    }\n  }\n\n  return debounce(update, 50);\n};","\"use strict\";\n\n/* eslint-disable */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case \"..\":\n        accumulator.pop();\n        break;\n\n      case \".\":\n        break;\n\n      default:\n        accumulator.push(item);\n    }\n\n    return accumulator;\n  }, []).join(\"/\");\n}\n\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n\n  var protocol = urlString.indexOf(\"//\") !== -1 ? urlString.split(\"//\")[0] + \"//\" : \"\";\n  var components = urlString.replace(new RegExp(protocol, \"i\"), \"\").split(\"/\");\n  var host = components[0].toLowerCase().replace(/\\.$/, \"\");\n  components[0] = \"\";\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};","// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      // 1634822411008\n      var cssReload = require(\"/home/runner/work/fintracts/fintracts/builder/node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  ","// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      // 1634822410885\n      var cssReload = require(\"/home/runner/work/fintracts/fintracts/builder/node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  ","/* Riot v6.0.2, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeChild);\n}\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\n\nconst removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\n\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\n\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),\n      PLUGINS_SET$1 = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol('pure'),\n      IS_COMPONENT_UPDATING = Symbol('is_updating'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  PLUGINS_SET: PLUGINS_SET$1,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nconst HEAD_SYMBOL = Symbol('head');\nconst TAIL_SYMBOL = Symbol('tail');\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\n\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Get the current <template> fragment children located in between the head and tail comments\n * @param {Comment} head - head comment node\n * @param {Comment} tail - tail comment node\n * @return {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction getFragmentChildren(_ref) {\n  let {\n    head,\n    tail\n  } = _ref;\n  const nodes = walkNodes([head], head.nextSibling, n => n === tail, false);\n  nodes.push(tail);\n  return nodes;\n}\n/**\n * Recursive function to walk all the <template> children nodes\n * @param {Array[]} children - children nodes collection\n * @param {ChildNode} node - current node\n * @param {Function} check - exit function check\n * @param {boolean} isFilterActive - filter flag to skip nodes managed by other bindings\n * @returns {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction walkNodes(children, node, check, isFilterActive) {\n  const {\n    nextSibling\n  } = node; // filter tail and head nodes together with all the nodes in between\n  // this is needed only to fix a really ugly edge case https://github.com/riot/riot/issues/2892\n\n  if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {\n    children.push(node);\n  }\n\n  if (!nextSibling || check(node)) return children;\n  return walkNodes(children, nextSibling, check, // activate the filters to skip nodes between <template> fragments that will be managed by other bindings\n  isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\n\nvar udomdiff = ((a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    } // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    } // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    } // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    } // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n\n      a[aEnd] = b[bEnd];\n    } // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n\n        while (i < bEnd) map.set(b[i], i++);\n      } // if it's a future node, hence it needs some handling\n\n\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS\n\n        if (bStart < index && index < bEnd) {\n          let i = aStart; // counts the amount of nodes that are the same in the future\n\n          let sequence = 1;\n\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n\n\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          } // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        } // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      } // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n\n  return b;\n});\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : []; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes; // make sure that the loop edge nodes are marked\n\n    markEdgeNodes(this.nodes);\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n};\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element; // remove the last node (notice <template> tags might have more children nodes)\n\n        nodes.pop(); // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n  return scope;\n}\n/**\n * Mark the first and last nodes in order to ignore them in case we need to retrieve the <template> fragment nodes\n * @param {Array[]} nodes - each binding nodes list\n * @returns {undefined} void function\n */\n\n\nfunction markEdgeNodes(nodes) {\n  const first = nodes[0];\n  const last = nodes[nodes.length - 1];\n  if (first) first[HEAD_SYMBOL] = true;\n  if (last) last[TAIL_SYMBOL] = true;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      nodes.push(...(mustMount ? meta.children : getFragmentChildren(meta)));\n    } else {\n      nodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key);\n    futureNodes.push(...nodes); // update the children map\n\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n};\nfunction create$5(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\n\n\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\n\n\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0;\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return value === true ? name : value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n};\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n};\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n};\nfunction create$2(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\n\n\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before\n\n    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n\n    const cloneNode = fragment || this.dom.cloneNode(true); // store root node\n    // notice that for template tags the root note will be the parent tag\n\n    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties\n\n    this.meta = meta;\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (mustRemoveRoot === void 0) {\n      mustRemoveRoot = false;\n    }\n\n    const el = this.el;\n\n    if (!el) {\n      return this;\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break;\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break;\n      // clean the node children only\n\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break;\n      // remove the root node only if the mustRemoveRoot is truly\n\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break;\n    }\n\n    this.el = null;\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create,\n  createBinding: create$1,\n  createExpression: create$4,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponent = memoize(createComponent);\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, componentWrapper) {\n  const components = createSubcomponents(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template(create, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponent(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentObject(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY,\n  COMPONENTS_IMPLEMENTATION_MAP,\n  PLUGINS_SET\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n\nconst withTypes = component => component;\n/** @type {string} current riot version */\n\nconst version = 'v6.0.2'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version, withTypes };\n","var map = {\n\t\"./builder/builder.riot\": 541\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 329;","import { register } from 'riot'\n\nconst basename = (path, extension = '') => path.split('/').reverse()[0].replace(extension, '')\nconst globalComponentsContext = require.context('./components/global/', true, /[a-zA-Z0-9-]+\\.riot/)\n\nexport default () => {\n  globalComponentsContext.keys().map(path => {\n    const name = basename(path, '.riot')\n\n    const component = globalComponentsContext(path)\n\n    register(name, component.default || component)\n\n    return {\n      name,\n      component\n    }\n  })\n}\n","import './style.css'\nimport 'tachyons'\nimport '@riotjs/hot-reload'\nimport { mount } from 'riot'\nimport registerGlobalComponents from './register-global-components'\n\n// register\nregisterGlobalComponents()\n\n// mount all the global components found in this page\nmount('[data-riot-component]')\n"],"names":["exports","riot","$","_interopDefaultLegacy","e","$__default","cssManager","__","DOM_COMPONENT_INSTANCE_PROPERTY","globals","reload","componentAPI","name","map","el","oldTag","unmount","remove","newTag","component","props","update","state","console","warn","default","Object","defineProperty","value","factory","components","PartySelect","Date","Money","Coupons","FrameBox","issuer","underwriter","faceValue","issuePrice","maturityDate","coupons","this","agreement","bondPurchase","onChange","field","addCoupons","parties","onRemove","Dates","rate","dates","onRate","event","Number","parseFloat","target","onCoupons","onDates","removeCoupons","ExchangeRate","InterestPayments","payerA","principalA","payerB","principalB","impliedExchangeRate","baseCurrency","counterCurrency","endExchangeRate","interest","effectiveDate","currencySwap","addEndExchangeRate","removeEndExchageRate","addInterestPayments","removeInterestPayments","currency","amount","notationalAmount","interestRateSwap","Parties","Agreements","Signatures","Contract","agreements","signatures","onValue","onPartiesDone","onAgreementsDone","onSignaturesDone","reset","contract","split","date","class","onDate","index","addDate","removeDate","splice","type","disabled","payer","onRateType","fixedRate","initialRate","rateOption","isValue","eventOrValue","isFloating","InterestPayment","newValue","addItem","preventDefault","stopPropagation","removeItem","toUpperCase","party","identifier","selected","types","id","title","Screen","BondPurchase","InterestRateSwap","CurrencySwap","onAgreement","onRemoveAgreement","onAgreementType","addAgreement","length","submit","onDone","key","canNext","text","JSON","stringify","Array","isArray","addParty","updateParty","i","dataset","deleteParty","reduce","valid","updateDate","filter","sig","selector","ctx","els","document","querySelectorAll","test","prototype","toString","call","from","normalizeUrl","srcByModuleId","create","noDocument","forEach","noop","updateCss","url","href","isUrlRequest","isLoaded","indexOf","visited","newEl","cloneNode","addEventListener","parentNode","removeChild","concat","now","nextSibling","insertBefore","appendChild","reloadAll","elements","module","moduleId","options","log","fn","timeout","getScriptSrc","src","currentScript","scripts","getElementsByTagName","lastScriptTag","fileMap","splitResult","filename","mapRule","reg","RegExp","replace","getCurrentScriptUrl","reloaded","loaded","ret","stripWWW","some","getReloadUrl","reloadStyle","locals","join","self","args","arguments","functionCall","apply","clearTimeout","setTimeout","urlString","trim","protocol","host","toLowerCase","accumulator","item","pop","push","cssReload","hot","dispose","accept","undefined","dashToCamelCase","string","_","c","moveChildren","source","firstChild","cleanNode","node","clearChildren","childNodes","children","newNode","refNode","COMPONENTS_IMPLEMENTATION_MAP$1","Map","DOM_COMPONENT_INSTANCE_PROPERTY$1","Symbol","PLUGINS_SET$1","Set","IS_DIRECTIVE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","IS_COMPONENT_UPDATING","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","freeze","__proto__","COMPONENTS_IMPLEMENTATION_MAP","PLUGINS_SET","VALUE_ATTRIBUTE","bindingTypes","EACH","IF","SIMPLE","TAG","SLOT","expressionTypes","ATTRIBUTE","EVENT","TEXT","VALUE","HEAD_SYMBOL","TAIL_SYMBOL","assign","enumerable","writable","configurable","defineProperties","properties","entries","_ref","defineDefaults","defaults","_ref2","getFragmentChildren","head","tail","nodes","walkNodes","n","check","isFilterActive","checkType","element","isSvg","owner","ownerSVGElement","isTemplate","tagName","isFunction","isObject","isNil","constructor","UNMOUNT_SCOPE","EachBinding","mount","scope","parentScope","placeholder","childrenMap","collection","evaluate","items","newChildrenMap","batches","futureNodes","binding","condition","template","itemName","getKey","indexName","root","isTemplateTag","context","extendScope","oldItem","get","mustFilterItem","mustMount","componentTemplate","clone","meta","fragment","dom","createTextNode","createHeadTailPlaceholders","avoidDOMInjection","createTemplateMeta","delete","set","createPatch","a","b","before","bLength","aEnd","bEnd","aStart","bStart","has","sequence","replaced","replaceChild","udomdiff","redundant","info","patch","values","first","last","markEdgeNodes","IfBinding","mustUnmount","pristine","panic","message","Error","memoize","cache","cached","val","evaluateAttributeExpressions","attributes","acc","attribute","ElementProto","Element","isNativeHtmlProperty","hasOwnProperty","RE_EVENTS_PREFIX","EventListener","handleEvent","ListenersWeakMap","WeakMap","normalizeStringValue","getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","expressions","attributeExpression","oldValue","newAttributes","oldAttributes","newKeys","keys","includes","removeAttribute","removeAllAttributes","setAllAttributes","isBoolean","shouldRemoveAttribute","canRenderAttribute","setAttribute","normalizeValue","normalizedEventName","eventListener","listener","createListener","callback","getCallbackAndOptions","handler","mustAddEvent","removeEventListener","data","expression","Expression","create$4","getRealParent","SlotBinding","getTemplateScope","attr","extendParentScope","templateData","slots","find","realParent","html","bindings","createDOM","moveSlotInnerContent","mustRemoveRoot","slot","child","slotBindings","TagBinding","tag","slotsToMarkup","getTag","getComponent","keepRootTag","method","fixTextExpressionsOffset","textExpressionsOffset","create$1","templateTagOffset","redundantAttribute","querySelector","bindingExpressions","injectDOM","TemplateChunk","container","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createSVGTree","createElement","innerHTML","content","createHTMLTree","createDOMTree","createTemplateDOM","createDocumentFragment","siblings","Math","max","getTemplateTagOffset","bindingsData","DOMBindings","createBinding","createExpression","callOrAssign","domToArray","normalize","attrs","prop","CSS_BY_NAME","style","add","css","inject","curry","_len","_key","_len2","_key2","getName","names","parseNodes","COMPONENT_CORE_HELPERS","$$","PURE_COMPONENT_API","COMPONENT_LIFECYCLE_METHODS","MOCKED_TEMPLATE_INTERFACE","memoizedCreateComponent","createComponent","bindDOMNodeToComponentObject","createCoreAPIMethods","mapFunction","componentWrapper","templateFn","_ref4","createSubcomponents","componentTemplateFactory","pureFactoryFunction","createPureComponent","defineComponent","preserveRoot","_ref3","enhanceComponentAPI","computeState","oldState","newState","_ref5","runPlugins","createAttributeBindings","initialProps","DOMattributesToObject","evaluateInitialProps","addCssHook","newProps","bind","register","unregister","componentName","mountComponent","keepRootElement","install","plugin","uninstall","implementation","_temp","fns","f","g","compose","pure","func","withTypes","version","webpackContext","req","webpackContextResolve","__webpack_require__","o","code","resolve","globalComponentsContext","path","extension","reverse","basename"],"sourceRoot":""}